#!/bin/sh

echo "üé£ CloudBlitz Pre-commit Hooks Starting..."

# Get list of staged files
STAGED_CLIENT_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep "^Client/" || true)
STAGED_SERVER_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep "^Server/" || true)
STAGED_ROOT_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E "^(package\.json|docker-compose|Dockerfile|\.env)" || true)

# Function to check if branch is protected
check_protected_branch() {
  BRANCH=$(git rev-parse --abbrev-ref HEAD)
  if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ] || [ "$BRANCH" = "develop" ]; then
    echo "‚ùå Direct commits to protected branch '$BRANCH' are not allowed!"
    echo "Please create a feature branch: git checkout -b feature/your-feature-name"
    exit 1
  fi
}

# Function to check commit message format (if this is not an amend)
check_commit_message() {
  if [ ! -f .git/COMMIT_EDITMSG ]; then
    return 0
  fi

  # Read the commit message
  COMMIT_MSG=$(head -n1 .git/COMMIT_EDITMSG)

  # Check if it follows conventional commits format
  if ! echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|perf|ci|build)(\(.+\))?: .{1,50}"; then
    echo "‚ùå Commit message does not follow conventional commits format!"
    echo "Format: type(scope): description"
    echo "Types: feat, fix, docs, style, refactor, test, chore, perf, ci, build"
    echo "Example: feat(auth): add user login functionality"
    exit 1
  fi
}

# Production-grade checks
echo "üîç Running production-grade pre-commit checks..."

# Check protected branches
check_protected_branch

# Check for secrets and sensitive data (basic patterns)
echo "üîê Checking for secrets and sensitive data..."
if git diff --cached -p | grep -E "password\s*[=:]\s*['\"].+['\"]|secret\s*[=:]\s*['\"].+['\"]|api_key\s*[=:]\s*['\"].+['\"]" > /dev/null 2>&1; then
  echo "‚ùå Potential secrets detected in code changes! Please review."
  echo "If this is intentional, consider using environment variables."
  exit 1
fi

# Check for large files
echo "üì¶ Checking for large files..."
for file in $(git diff --cached --name-only); do
  if [ -f "$file" ]; then
    size=$(wc -c < "$file" 2>/dev/null || echo 0)
    if [ $size -gt 1048576 ]; then  # 1MB
      echo "‚ùå Large file detected: $file ($(($size/1024))KB)"
      echo "Consider using Git LFS for large files."
      exit 1
    fi
  fi
done

# Run Client checks
if [ -n "$STAGED_CLIENT_FILES" ]; then
  echo "üîç Running Client-side checks..."
  cd Client

  # Run lint-staged with comprehensive checks
  if ! npx lint-staged; then
    echo "‚ùå Client lint-staged checks failed"
    exit 1
  fi

  # Additional Client checks
  echo "üèóÔ∏è Building Client to verify no build errors..."
  if ! npm run build > /dev/null 2>&1; then
    echo "‚ùå Client build failed! Fix build errors before committing."
    exit 1
  fi

  cd ..
  echo "‚úÖ Client checks passed!"
fi

# Run Server checks
if [ -n "$STAGED_SERVER_FILES" ]; then
  echo "üîç Running Server-side checks..."
  cd Server

  # Run lint-staged with comprehensive checks
  if ! npx lint-staged; then
    echo "‚ùå Server lint-staged checks failed"
    exit 1
  fi

  # Additional Server checks
  echo "üèóÔ∏è Building Server to verify no build errors..."
  if ! npm run build > /dev/null 2>&1; then
    echo "‚ùå Server build failed! Fix build errors before committing."
    exit 1
  fi

  cd ..
  echo "‚úÖ Server checks passed!"
fi

# Check root configuration files
if [ -n "$STAGED_ROOT_FILES" ]; then
  echo "üìã Validating root configuration files..."

  # Validate docker-compose files
  for file in $(echo "$STAGED_ROOT_FILES" | grep "docker-compose"); do
    if [ -f "$file" ]; then
      if ! docker-compose -f "$file" config > /dev/null 2>&1; then
        echo "‚ùå Invalid docker-compose file: $file"
        exit 1
      fi
    fi
  done

  echo "‚úÖ Root configuration files validated!"
fi

# Final success message
echo "üéâ All pre-commit checks passed! Commit proceeding..."
echo "üìä Summary:"
[ -n "$STAGED_CLIENT_FILES" ] && echo "  ‚Ä¢ Client files: $(echo "$STAGED_CLIENT_FILES" | wc -l) files checked"
[ -n "$STAGED_SERVER_FILES" ] && echo "  ‚Ä¢ Server files: $(echo "$STAGED_SERVER_FILES" | wc -l) files checked"
[ -n "$STAGED_ROOT_FILES" ] && echo "  ‚Ä¢ Root config files: $(echo "$STAGED_ROOT_FILES" | wc -l) files checked"

exit 0